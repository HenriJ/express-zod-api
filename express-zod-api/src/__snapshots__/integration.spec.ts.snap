// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`API Integration Generator Feature #945: should have configurable treatment of optionals 0 1`] = `
"type PostV1TestWithDashesInput = {
    opt?: string;
};

type PostV1TestWithDashesResponse = {
    status: "success";
    data: {
        similar?: number;
    };
} | {
    status: "error";
    error: {
        message: string;
    };
};

export type Path = "/v1/test-with-dashes";

export type Method = "get" | "post" | "put" | "delete" | "patch";

export type MethodPath = \`\${Method} \${Path}\`;

export interface Input extends Record<MethodPath, any> {
    "post /v1/test-with-dashes": PostV1TestWithDashesInput;
}

export interface Response extends Record<MethodPath, any> {
    "post /v1/test-with-dashes": PostV1TestWithDashesResponse;
}

export const jsonEndpoints = { "post /v1/test-with-dashes": true };

export const endpointTags = { "post /v1/test-with-dashes": [] };

export type Provider = <M extends Method, P extends Path>(method: M, path: P, params: Input[\`\${M} \${P}\`]) => Promise<Response[\`\${M} \${P}\`]>;

export type Implementation = (method: Method, path: string, params: Record<string, any>) => Promise<any>;

/*
export const exampleImplementation: Implementation = async (
  method,
  path,
  params
) => {
  const hasBody = !["get", "delete"].includes(method);
  const searchParams = hasBody ? "" : \`?\${new URLSearchParams(params)}\`;
  const response = await fetch(\`https://example.com\${path}\${searchParams}\`, {
    method: method.toUpperCase(),
    headers: hasBody ? { "Content-Type": "application/json" } : undefined,
    body: hasBody ? JSON.stringify(params) : undefined,
  });
  if (\`\${method} \${path}\` in jsonEndpoints) {
    return response.json();
  }
  return response.text();
};

const client = new ExpressZodAPIClient(exampleImplementation);
client.provide("get", "/v1/user/retrieve", { id: "10" });
*/
export class ExpressZodAPIClient {
    constructor(protected readonly implementation: Implementation) { }
    public readonly provide: Provider = async (method, path, params) => this.implementation(method, Object.keys(params).reduce((acc, key) => acc.replace(\`:\${key}\`, params[key]), path), Object.keys(params).reduce((acc, key) => path.indexOf(\`:\${key}\`) >= 0 ? acc : { ...acc, [key]: params[key] }, {}));
}"
`;

exports[`API Integration Generator Feature #945: should have configurable treatment of optionals 1 1`] = `
"type PostV1TestWithDashesInput = {
    opt: string | undefined;
};

type PostV1TestWithDashesResponse = {
    status: "success";
    data: {
        similar: number | undefined;
    };
} | {
    status: "error";
    error: {
        message: string;
    };
};

export type Path = "/v1/test-with-dashes";

export type Method = "get" | "post" | "put" | "delete" | "patch";

export type MethodPath = \`\${Method} \${Path}\`;

export interface Input extends Record<MethodPath, any> {
    "post /v1/test-with-dashes": PostV1TestWithDashesInput;
}

export interface Response extends Record<MethodPath, any> {
    "post /v1/test-with-dashes": PostV1TestWithDashesResponse;
}

export const jsonEndpoints = { "post /v1/test-with-dashes": true };

export const endpointTags = { "post /v1/test-with-dashes": [] };

export type Provider = <M extends Method, P extends Path>(method: M, path: P, params: Input[\`\${M} \${P}\`]) => Promise<Response[\`\${M} \${P}\`]>;

export type Implementation = (method: Method, path: string, params: Record<string, any>) => Promise<any>;

/*
export const exampleImplementation: Implementation = async (
  method,
  path,
  params
) => {
  const hasBody = !["get", "delete"].includes(method);
  const searchParams = hasBody ? "" : \`?\${new URLSearchParams(params)}\`;
  const response = await fetch(\`https://example.com\${path}\${searchParams}\`, {
    method: method.toUpperCase(),
    headers: hasBody ? { "Content-Type": "application/json" } : undefined,
    body: hasBody ? JSON.stringify(params) : undefined,
  });
  if (\`\${method} \${path}\` in jsonEndpoints) {
    return response.json();
  }
  return response.text();
};

const client = new ExpressZodAPIClient(exampleImplementation);
client.provide("get", "/v1/user/retrieve", { id: "10" });
*/
export class ExpressZodAPIClient {
    constructor(protected readonly implementation: Implementation) { }
    public readonly provide: Provider = async (method, path, params) => this.implementation(method, Object.keys(params).reduce((acc, key) => acc.replace(\`:\${key}\`, params[key]), path), Object.keys(params).reduce((acc, key) => path.indexOf(\`:\${key}\`) >= 0 ? acc : { ...acc, [key]: params[key] }, {}));
}"
`;

exports[`API Integration Generator Feature #945: should have configurable treatment of optionals 2 1`] = `
"type PostV1TestWithDashesInput = {
    opt: string;
};

type PostV1TestWithDashesResponse = {
    status: "success";
    data: {
        similar: number;
    };
} | {
    status: "error";
    error: {
        message: string;
    };
};

export type Path = "/v1/test-with-dashes";

export type Method = "get" | "post" | "put" | "delete" | "patch";

export type MethodPath = \`\${Method} \${Path}\`;

export interface Input extends Record<MethodPath, any> {
    "post /v1/test-with-dashes": PostV1TestWithDashesInput;
}

export interface Response extends Record<MethodPath, any> {
    "post /v1/test-with-dashes": PostV1TestWithDashesResponse;
}

export const jsonEndpoints = { "post /v1/test-with-dashes": true };

export const endpointTags = { "post /v1/test-with-dashes": [] };

export type Provider = <M extends Method, P extends Path>(method: M, path: P, params: Input[\`\${M} \${P}\`]) => Promise<Response[\`\${M} \${P}\`]>;

export type Implementation = (method: Method, path: string, params: Record<string, any>) => Promise<any>;

/*
export const exampleImplementation: Implementation = async (
  method,
  path,
  params
) => {
  const hasBody = !["get", "delete"].includes(method);
  const searchParams = hasBody ? "" : \`?\${new URLSearchParams(params)}\`;
  const response = await fetch(\`https://example.com\${path}\${searchParams}\`, {
    method: method.toUpperCase(),
    headers: hasBody ? { "Content-Type": "application/json" } : undefined,
    body: hasBody ? JSON.stringify(params) : undefined,
  });
  if (\`\${method} \${path}\` in jsonEndpoints) {
    return response.json();
  }
  return response.text();
};

const client = new ExpressZodAPIClient(exampleImplementation);
client.provide("get", "/v1/user/retrieve", { id: "10" });
*/
export class ExpressZodAPIClient {
    constructor(protected readonly implementation: Implementation) { }
    public readonly provide: Provider = async (method, path, params) => this.implementation(method, Object.keys(params).reduce((acc, key) => acc.replace(\`:\${key}\`, params[key]), path), Object.keys(params).reduce((acc, key) => path.indexOf(\`:\${key}\`) >= 0 ? acc : { ...acc, [key]: params[key] }, {}));
}"
`;

exports[`API Integration Generator Should support types variant and handle recirsive schemas 1`] = `
"type Type118cb3b11b8a1f3b6b1e60a89f96a8be9da32a0f = {
    name: string;
    features: Type118cb3b11b8a1f3b6b1e60a89f96a8be9da32a0f;
};

type PostV1TestInput = {
    features: Type118cb3b11b8a1f3b6b1e60a89f96a8be9da32a0f;
};

type PostV1TestResponse = {
    status: "success";
    data: {};
} | {
    status: "error";
    error: {
        message: string;
    };
};

export type Path = "/v1/test";

export type Method = "get" | "post" | "put" | "delete" | "patch";

export type MethodPath = \`\${Method} \${Path}\`;

export interface Input extends Record<MethodPath, any> {
    "post /v1/test": PostV1TestInput;
}

export interface Response extends Record<MethodPath, any> {
    "post /v1/test": PostV1TestResponse;
}"
`;

exports[`API Integration Generator Should treat optionals the same way as z.infer() by default 1`] = `
"type PostV1TestWithDashesInput = {
    opt?: string | undefined;
};

type PostV1TestWithDashesResponse = {
    status: "success";
    data: {
        similar?: number | undefined;
    };
} | {
    status: "error";
    error: {
        message: string;
    };
};

export type Path = "/v1/test-with-dashes";

export type Method = "get" | "post" | "put" | "delete" | "patch";

export type MethodPath = \`\${Method} \${Path}\`;

export interface Input extends Record<MethodPath, any> {
    "post /v1/test-with-dashes": PostV1TestWithDashesInput;
}

export interface Response extends Record<MethodPath, any> {
    "post /v1/test-with-dashes": PostV1TestWithDashesResponse;
}

export const jsonEndpoints = { "post /v1/test-with-dashes": true };

export const endpointTags = { "post /v1/test-with-dashes": ["one", "two"] };

export type Provider = <M extends Method, P extends Path>(method: M, path: P, params: Input[\`\${M} \${P}\`]) => Promise<Response[\`\${M} \${P}\`]>;

export type Implementation = (method: Method, path: string, params: Record<string, any>) => Promise<any>;

/*
export const exampleImplementation: Implementation = async (
  method,
  path,
  params
) => {
  const hasBody = !["get", "delete"].includes(method);
  const searchParams = hasBody ? "" : \`?\${new URLSearchParams(params)}\`;
  const response = await fetch(\`https://example.com\${path}\${searchParams}\`, {
    method: method.toUpperCase(),
    headers: hasBody ? { "Content-Type": "application/json" } : undefined,
    body: hasBody ? JSON.stringify(params) : undefined,
  });
  if (\`\${method} \${path}\` in jsonEndpoints) {
    return response.json();
  }
  return response.text();
};

const client = new ExpressZodAPIClient(exampleImplementation);
client.provide("get", "/v1/user/retrieve", { id: "10" });
*/
export class ExpressZodAPIClient {
    constructor(protected readonly implementation: Implementation) { }
    public readonly provide: Provider = async (method, path, params) => this.implementation(method, Object.keys(params).reduce((acc, key) => acc.replace(\`:\${key}\`, params[key]), path), Object.keys(params).reduce((acc, key) => path.indexOf(\`:\${key}\`) >= 0 ? acc : { ...acc, [key]: params[key] }, {}));
}"
`;
